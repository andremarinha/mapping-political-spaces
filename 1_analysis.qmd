---
title: "Analysis: Mapping Political Spaces in Southern Europe"
author: "André Marinha"
date: today
format:
  html:
    embed-resources: true
    toc: true
    toc-depth: 3
    code-fold: true
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
  cache: true
bibliography: assets/bib.bib
---

# Setup {.unnumbered}

```{r}
#| label: setup
#| cache: false

library(tidyverse)
library(FactoMineR)
library(factoextra)
library(poLCA)
library(patchwork)
library(scales)

# poLCA loads MASS which masks dplyr::select — restore it
select <- dplyr::select

theme_set(theme_minimal(base_size = 12))

# Colour palette (project standard)
plasma_pal <- viridis::plasma

# Benzécri correction for MCA eigenvalues
# In standard MCA, eigenvalues are deflated by disjunctive coding.
# The correction retains only eigenvalues > 1/J (where J = number of active
# variables) and computes: modified_λ = ((J/(J-1)) * (λ - 1/J))²
# Modified rates = modified_λ / Σ(modified_λ) × 100
benzecri_correction <- function(eig_table, J) {
  eig_raw <- eig_table[, 1]
  threshold <- 1 / J

  mask <- eig_raw > threshold
  eig_kept <- eig_raw[mask]

  modified <- ((J / (J - 1)) * (eig_kept - threshold))^2
  mod_pct  <- 100 * modified / sum(modified)
  mod_cum  <- cumsum(mod_pct)

  data.frame(
    dimension          = seq_along(modified),
    raw_eigenvalue     = eig_kept,
    modified_eigenvalue = modified,
    modified_pct       = mod_pct,
    cumulative_pct     = mod_cum
  )
}

# Load master dataset
df <- readRDS("data/master/ess_final.rds")

# Define key variable sets
active_vars <- c("freehms_r", "gincdif_r",
                  "imbgeco_3cat", "imueclt_3cat", "imwbcnt_3cat")

participation_vars <- c("badge_d", "bctprd_d", "contplt_d",
                         "sgnptit_d", "pbldmn_d", "vote_d")

sup_vars_socdem <- c("oesch8", "domicil_r", "income_quint_h",
                      "eisced_5cat_h", "mother_edu_5cat", "father_edu_5cat")

countries <- c("PT", "ES", "GR", "IT")
country_labels <- c(PT = "Portugal", ES = "Spain", GR = "Greece", IT = "Italy")
```

# Data Overview

```{r}
#| label: data-overview

cat("Master dimensions:", nrow(df), "x", ncol(df), "\n")
cat("Countries:", paste(unique(df$cntry), collapse = ", "), "\n")
cat("Rounds:", paste(sort(unique(df$essround)), collapse = ", "), "\n\n")

# Observations by country and round
cat("--- Sample size by country x round ---\n")
print(addmargins(table(df$cntry, df$essround)))

# Complete cases on MFA active variables
df_active <- df %>% filter(if_all(all_of(active_vars), ~ !is.na(.)))
cat("\n--- MFA active variable complete cases ---\n")
cat("Total:", nrow(df_active), "/", nrow(df),
    "(", round(100 * nrow(df_active) / nrow(df), 1), "%)\n")
print(addmargins(table(df_active$cntry, df_active$essround)))
```


# LCA: Participation Repertoires

Latent Class Analysis identifies distinct **participation repertoires** from the
six binary political participation indicators. The measurement model is purely
behavioural: class membership is determined by patterns of participation, not by
social characteristics. Oesch classes, party vote, and other structural variables
are kept separate and will be projected as supplementary in the MFA space.

Following Oser (2022) and Jeroense & Spierings (2023), we fit pooled
within-country LCA models. Pooling across rounds maximises sample size and
produces stable repertoire types; temporal variation in repertoire prevalence
is captured downstream when examining class x round distributions.

## Data Preparation

```{r}
#| label: lca-data-prep

# poLCA requires:
#   - Variables coded as integers starting from 1 (not 0)
#   - No NAs on indicator variables (rows with any NA are dropped)

lca_data <- df %>%
  select(idno, cntry, essround, all_of(participation_vars)) %>%
  # Recode 0/1 -> 1/2 for poLCA (1 = No, 2 = Yes)
  mutate(across(all_of(participation_vars), ~ . + 1L)) %>%
  # Keep only complete cases on all 6 indicators
  filter(if_all(all_of(participation_vars), ~ !is.na(.)))

cat("LCA-ready observations:", nrow(lca_data), "/", nrow(df), "\n\n")
cat("By country:\n")
print(table(lca_data$cntry))
cat("\nBy country x round:\n")
print(addmargins(table(lca_data$cntry, lca_data$essround)))
```

## Model Fitting

```{r}
#| label: lca-fit-function

# Helper: fit LCA models from K=2 to K=maxK, return list of results
fit_lca_range <- function(data, vars, maxK = 6, nrep = 20, seed = 42) {

  f <- as.formula(paste0("cbind(",
                          paste(vars, collapse = ", "),
                          ") ~ 1"))

  results <- list()
  for (k in 2:maxK) {
    set.seed(seed)
    fit <- poLCA(f, data = data, nclass = k, nrep = nrep,
                 maxiter = 3000, tol = 1e-6,
                 verbose = FALSE, graphs = FALSE)
    results[[paste0("K", k)]] <- fit
  }
  return(results)
}

# Helper: extract fit statistics
lca_fit_table <- function(models) {
  tibble(
    K       = as.integer(gsub("K", "", names(models))),
    logLik  = map_dbl(models, ~ .x$llik),
    AIC     = map_dbl(models, ~ .x$aic),
    BIC     = map_dbl(models, ~ .x$bic),
    npar    = map_dbl(models, ~ .x$npar),
    Gsq     = map_dbl(models, ~ .x$Gsq),
    # Entropy: 1 - (sum of individual classification uncertainty) / (N * log(K))
    entropy = map2_dbl(models, as.integer(gsub("K", "", names(models))), function(m, k) {
      pp <- m$posterior
      pp[pp < 1e-10] <- 1e-10  # avoid log(0)
      H <- -sum(pp * log(pp))
      1 - H / (nrow(pp) * log(k))
    })
  )
}
```

```{r}
#| label: lca-fit-all
#| cache: true

# Fit LCA models per country (K=2 to K=6)
lca_models <- list()
lca_fits   <- list()

for (cc in countries) {
  cat("Fitting LCA for", country_labels[cc], "...\n")
  cc_data <- lca_data %>% filter(cntry == cc)
  lca_models[[cc]] <- fit_lca_range(cc_data, participation_vars)
  lca_fits[[cc]]   <- lca_fit_table(lca_models[[cc]])
}
```

## Model Selection

```{r}
#| label: lca-model-selection
#| fig-width: 10
#| fig-height: 8

# Plot BIC and entropy for all countries
plots_bic <- list()
plots_ent <- list()

for (cc in countries) {
  ft <- lca_fits[[cc]]

  plots_bic[[cc]] <- ggplot(ft, aes(K, BIC)) +
    geom_line(linewidth = 0.8) + geom_point(size = 2) +
    scale_x_continuous(breaks = ft$K) +
    labs(title = country_labels[cc], y = "BIC") +
    theme(plot.title = element_text(face = "bold", size = 11))

  plots_ent[[cc]] <- ggplot(ft, aes(K, entropy)) +
    geom_line(linewidth = 0.8) + geom_point(size = 2) +
    scale_x_continuous(breaks = ft$K) +
    scale_y_continuous(limits = c(0, 1)) +
    labs(title = country_labels[cc], y = "Entropy") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(plots_bic[["PT"]] + plots_bic[["ES"]] + plots_bic[["GR"]] + plots_bic[["IT"]]) /
(plots_ent[["PT"]] + plots_ent[["ES"]] + plots_ent[["GR"]] + plots_ent[["IT"]]) +
  plot_annotation(title = "LCA Model Selection: BIC and Entropy by Number of Classes")
```

```{r}
#| label: lca-fit-tables

# Print fit tables
for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  print(lca_fits[[cc]], n = 10)
}
```

## Class Profiles

After inspecting the BIC and entropy plots above, select the optimal K for each
country. The default below uses the K that minimises BIC. Adjust manually if
substantive interpretability suggests a different solution.

```{r}
#| label: lca-select-k

# Select K per country: minimum BIC (can be overridden manually)
selected_k <- map_int(lca_fits, ~ .x$K[which.min(.x$BIC)])
cat("Selected K (min BIC):\n")
print(selected_k)

# Extract the selected models
lca_selected <- map2(lca_models, paste0("K", selected_k), ~ .x[[.y]])
```

```{r}
#| label: lca-profiles
#| fig-width: 12
#| fig-height: 10

# Item-response probability plots
participation_labels <- c(
  badge_d   = "Worn badge",
  bctprd_d  = "Boycotted",
  contplt_d = "Contacted politician",
  sgnptit_d = "Signed petition",
  pbldmn_d  = "Demonstrated",
  vote_d    = "Voted"
)

plot_lca_profiles <- function(model, country_label) {
  probs <- model$probs
  K <- length(probs[[1]][,1])

  # Extract P(Yes) for each item and class
  prof_df <- map_dfr(names(probs), function(var) {
    # Column 2 = P(response = 2) = P(Yes) since we coded 1=No, 2=Yes
    tibble(
      variable = var,
      class = 1:K,
      prob_yes = probs[[var]][, 2]
    )
  })

  prof_df <- prof_df %>%
    mutate(
      variable = factor(variable, levels = participation_vars,
                        labels = participation_labels),
      class = factor(class)
    )

  ggplot(prof_df, aes(variable, prob_yes, fill = class)) +
    geom_col(position = position_dodge(width = 0.8), width = 0.7) +
    scale_y_continuous(limits = c(0, 1), labels = percent) +
    scale_fill_viridis_d(option = "plasma", end = 0.85) +
    labs(title = country_label,
         x = NULL, y = "P(Yes)", fill = "Class") +
    theme(axis.text.x = element_text(angle = 30, hjust = 1),
          plot.title = element_text(face = "bold"))
}

profile_plots <- map2(lca_selected, country_labels[names(lca_selected)],
                       plot_lca_profiles)

(profile_plots[[1]] + profile_plots[[2]]) /
(profile_plots[[3]] + profile_plots[[4]]) +
  plot_annotation(title = "LCA Item-Response Probabilities (P(Yes) by Class)")
```

```{r}
#| label: lca-class-sizes

# Class prevalence (mixing proportions)
for (cc in countries) {
  model <- lca_selected[[cc]]
  cat("\n===", country_labels[cc], "(K =", selected_k[cc], ") ===\n")
  cat("Class sizes (proportions):\n")
  print(round(model$P, 3))
  cat("Class sizes (N):\n")
  print(round(model$P * model$N))
}
```

## Assign Repertoire Classes

```{r}
#| label: lca-assign

# Assign each individual to their most likely class (modal assignment)
# Add back to the LCA data, then merge to master

lca_assignments <- list()
for (cc in countries) {
  cc_data <- lca_data %>% filter(cntry == cc)
  model <- lca_selected[[cc]]
  cc_data$lca_class <- model$predclass
  lca_assignments[[cc]] <- cc_data %>% select(idno, cntry, essround, lca_class)
}

lca_all <- bind_rows(lca_assignments)

# Merge to master: add lca_class column
df <- df %>%
  left_join(lca_all %>% select(idno, cntry, essround, lca_class),
            by = c("idno", "cntry", "essround"))

cat("LCA class assigned:", sum(!is.na(df$lca_class)), "/", nrow(df), "\n")
cat("By country:\n")
print(table(df$cntry[!is.na(df$lca_class)]))
```


# MFA: Political Space Construction

Multiple Factor Analysis constructs a **political space** from the five
attitudinal variables. Each ESS round forms a separate group (block) of the same
five variables. MFA normalises each round's contribution and produces:

- A **compromise space**: the common structure of political attitudes across all rounds
- **Partial representations**: how each round deviates from the compromise
- **Supplementary projections**: where social classes, income groups, education
  levels, urbanisation categories, and participation repertoires sit in the space

The active variables defining the political space are all categorical:

- `freehms_r` (1–5): Gay rights (cultural liberalism)
- `gincdif_r` (1–5): Income redistribution (economic egalitarianism)
- `imbgeco_3cat` (1–3): Immigration — economy
- `imueclt_3cat` (1–3): Immigration — culture
- `imwbcnt_3cat` (1–3): Immigration — overall

## Helper Functions

```{r}
#| label: mfa-helpers

# Build the wide data frame for MFA
# Each round becomes a group of 5 active variables (all categorical)
# Individuals only have data in their own round's columns; rest are NA
# Supplementary variables are appended as additional groups

build_mfa_data <- function(data, active_vars, sup_vars, country) {

  # Filter to country + complete cases on active vars
  cd <- data %>%
    filter(cntry == country) %>%
    filter(if_all(all_of(active_vars), ~ !is.na(.)))

  rounds <- sort(unique(cd$essround))
  n <- nrow(cd)
  n_active <- length(active_vars)
  n_rounds <- length(rounds)

  # --- Active groups: one per round ---
  active_cols <- list()
  for (i in seq_along(rounds)) {
    r <- rounds[i]
    for (v in active_vars) {
      col_name <- paste0(v, "_R", r)
      active_cols[[col_name]] <- rep(NA_integer_, n)
      idx <- which(cd$essround == r)
      active_cols[[col_name]][idx] <- cd[[v]][idx]
    }
  }
  wide <- as.data.frame(active_cols)

  # Convert active columns to factors
  for (col in names(wide)) {
    wide[[col]] <- factor(wide[[col]])
  }

  # --- Supplementary variables ---
  for (v in sup_vars) {
    wide[[v]] <- factor(cd[[v]])
  }

  # --- MFA parameters ---
  group_sizes <- c(rep(n_active, n_rounds), rep(1, length(sup_vars)))
  group_types <- c(rep("n", n_rounds), rep("n", length(sup_vars)))
  group_names <- c(paste0("R", rounds), sup_vars)
  sup_group_idx <- (n_rounds + 1):(n_rounds + length(sup_vars))

  list(
    data        = wide,
    group       = group_sizes,
    type        = group_types,
    name.group  = group_names,
    num.group.sup = sup_group_idx,
    rounds      = rounds,
    meta        = cd %>% select(idno, cntry, essround, oesch8_label)
  )
}

# Run MFA
run_mfa <- function(mfa_input, ncp = 5) {
  MFA(mfa_input$data,
      group         = mfa_input$group,
      type          = mfa_input$type,
      name.group    = mfa_input$name.group,
      num.group.sup = mfa_input$num.group.sup,
      ncp           = ncp,
      graph         = FALSE)
}
```

## Run MFA per Country

```{r}
#| label: mfa-run
#| cache: true

# Include LCA class as supplementary if available
sup_all <- c(sup_vars_socdem, "lca_class")

mfa_inputs  <- list()
mfa_results <- list()

for (cc in countries) {
  cat("Building MFA data for", country_labels[cc], "...\n")
  mfa_inputs[[cc]] <- build_mfa_data(df, active_vars, sup_all, cc)
  cat("  Individuals:", nrow(mfa_inputs[[cc]]$data),
      "| Rounds:", length(mfa_inputs[[cc]]$rounds),
      "| Groups:", length(mfa_inputs[[cc]]$group), "\n")

  cat("Running MFA for", country_labels[cc], "...\n")
  mfa_results[[cc]] <- run_mfa(mfa_inputs[[cc]])
  cat("  Done.\n\n")
}
```

## Dimensionality

**Note on eigenvalue structure:** Because the ESS is a repeated cross-section
(not a panel), each individual appears in only **one** round group. The MFA
normalisation and the block-diagonal indicator matrix produce a characteristic
flat eigenvalue structure with low per-dimension inertia percentages. This is
expected and does not indicate a poor solution. Interpretation focuses on the
**category oppositions** and **supplementary projections**, not on variance
thresholds. The RV coefficients between rounds will also be near zero because
groups share no individuals — they capture structural similarity of category
configurations, not individual-level correlations.

```{r}
#| label: mfa-eigenvalues
#| fig-width: 10
#| fig-height: 8

# Scree plots — raw MFA eigenvalues
eig_plots <- list()
for (cc in countries) {
  eig <- mfa_results[[cc]]$eig
  eig_df <- tibble(
    dim = 1:nrow(eig),
    eigenvalue = eig[, 1],
    pct_var    = eig[, 2],
    cum_var    = eig[, 3]
  )

  eig_plots[[cc]] <- ggplot(eig_df %>% filter(dim <= 10),
                             aes(dim, pct_var)) +
    geom_col(fill = plasma_pal(10)[3], width = 0.7) +
    geom_line(aes(y = cum_var), colour = "grey40", linewidth = 0.6) +
    geom_point(aes(y = cum_var), colour = "grey40", size = 1.5) +
    scale_x_continuous(breaks = 1:10) +
    labs(title = country_labels[cc],
         x = "Dimension", y = "% of variance (inertia)") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(eig_plots[["PT"]] + eig_plots[["ES"]]) /
(eig_plots[["GR"]] + eig_plots[["IT"]]) +
  plot_annotation(
    title = "MFA Scree Plots",
    subtitle = "Bars = % variance per dimension | Line = cumulative %"
  )
```

```{r}
#| label: mfa-eigenvalue-tables

for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  eig <- mfa_results[[cc]]$eig
  print(round(eig[1:min(10, nrow(eig)), ], 3))
}
```

## RV Coefficients (Round Similarity)

```{r}
#| label: mfa-rv-coefficients
#| fig-width: 10
#| fig-height: 8

rv_plots <- list()
for (cc in countries) {
  rv_mat <- mfa_results[[cc]]$group$RV
  # Keep only active groups (exclude supplementary)
  n_active <- length(mfa_inputs[[cc]]$rounds)
  rv_active <- rv_mat[1:n_active, 1:n_active]
  rownames(rv_active) <- paste0("R", mfa_inputs[[cc]]$rounds)
  colnames(rv_active) <- paste0("R", mfa_inputs[[cc]]$rounds)

  rv_long <- as.data.frame(as.table(rv_active)) %>%
    rename(Round1 = Var1, Round2 = Var2, RV = Freq)

  rv_plots[[cc]] <- ggplot(rv_long, aes(Round1, Round2, fill = RV)) +
    geom_tile() +
    geom_text(aes(label = round(RV, 2)), size = 2.5) +
    scale_fill_viridis_c(option = "plasma", limits = c(0, 1)) +
    labs(title = country_labels[cc], x = NULL, y = NULL) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          plot.title = element_text(face = "bold", size = 11))
}

(rv_plots[["PT"]] + rv_plots[["ES"]]) /
(rv_plots[["GR"]] + rv_plots[["IT"]]) +
  plot_annotation(title = "RV Coefficients Between ESS Rounds (MFA Groups)")
```

## Dimension Interpretation: Variable Contributions

```{r}
#| label: mfa-var-contributions
#| fig-width: 12
#| fig-height: 10

# For each country: which variables contribute most to each dimension?
for (cc in countries) {
  cat("\n===", country_labels[cc], ": Group contributions to Dim 1 & 2 ===\n")
  grp_contrib <- mfa_results[[cc]]$group$contrib
  n_active <- length(mfa_inputs[[cc]]$rounds)
  print(round(grp_contrib[1:n_active, 1:2], 2))
}
```

```{r}
#| label: mfa-category-contrib
#| fig-width: 12
#| fig-height: 10

# Category contributions to Dim 1 and Dim 2 (compromise)
for (cc in countries) {
  cat("\n===", country_labels[cc], ": Top 15 category contributions ===\n")

  # quali.var contains category-level results for active groups
  cat_contrib <- mfa_results[[cc]]$quali.var$contrib
  cat_coord   <- mfa_results[[cc]]$quali.var$coord

  cat("\n-- Dim 1 (top 15 contributors) --\n")
  top1 <- head(cat_contrib[order(-cat_contrib[, 1]), , drop = FALSE], 15)
  print(round(cbind(top1[, 1, drop = FALSE], coord = cat_coord[rownames(top1), 1]), 3))

  cat("\n-- Dim 2 (top 15 contributors) --\n")
  top2 <- head(cat_contrib[order(-cat_contrib[, 2]), , drop = FALSE], 15)
  print(round(cbind(top2[, 2, drop = FALSE], coord = cat_coord[rownames(top2), 2]), 3))
}
```

## Category Configuration Maps

```{r}
#| label: mfa-category-maps
#| fig-width: 12
#| fig-height: 10

# Compromise category maps (Dim 1 x Dim 2)
cat_map_plots <- list()
for (cc in countries) {
  coord <- as.data.frame(mfa_results[[cc]]$quali.var$coord[, 1:2])
  coord$category <- rownames(coord)

  # Extract the base variable name (before _R suffix)
  coord$variable <- sub("_R\\d+\\..*$", "", coord$category)
  # Clean category label
  coord$label <- sub("^.*\\.", "", coord$category)

  cat_map_plots[[cc]] <- ggplot(coord, aes(Dim.1, Dim.2,
                                            colour = variable, label = label)) +
    geom_point(size = 2, alpha = 0.7) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    ggrepel::geom_text_repel(size = 2.5, max.overlaps = 20, show.legend = FALSE) +
    scale_colour_viridis_d(option = "plasma", end = 0.85) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(mfa_results[[cc]]$eig[1, 2], 1), "%)"),
         y = paste0("Dim 2 (", round(mfa_results[[cc]]$eig[2, 2], 1), "%)"),
         colour = "Variable") +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom")
}

(cat_map_plots[["PT"]] + cat_map_plots[["ES"]]) /
(cat_map_plots[["GR"]] + cat_map_plots[["IT"]]) +
  plot_annotation(title = "MFA Compromise: Category Configurations (Dim 1 x 2)")
```


# Supplementary Projections

```{r}
#| label: mfa-supplementary
#| fig-width: 12
#| fig-height: 10

# Extract supplementary category coordinates (barycentres)
# These are computed by MFA for the supplementary groups

sup_bary_plots <- list()
for (cc in countries) {
  # quali.var.sup contains supplementary qualitative variable results
  sup_coord <- as.data.frame(mfa_results[[cc]]$quali.var.sup$coord[, 1:2])
  sup_coord$category <- rownames(sup_coord)

  # Identify which supplementary variable each category belongs to
  sup_coord$variable <- NA_character_
  for (sv in sup_all) {
    idx <- grepl(paste0("^", sv, "\\."), sup_coord$category) |
           sup_coord$category %in% paste0(sv, ".", levels(factor(df[[sv]])))
    sup_coord$variable[idx] <- sv
  }
  # Clean label
  sup_coord$label <- sub("^[^\\.]+\\.", "", sup_coord$category)

  # Plot Oesch-8 classes separately (main interest)
  oesch_coord <- sup_coord %>% filter(variable == "oesch8")

  sup_bary_plots[[cc]] <- ggplot(oesch_coord,
                                  aes(Dim.1, Dim.2, label = label)) +
    geom_point(size = 3, colour = plasma_pal(8)[4]) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    ggrepel::geom_text_repel(size = 3, max.overlaps = 15) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(mfa_results[[cc]]$eig[1, 2], 1), "%)"),
         y = paste0("Dim 2 (", round(mfa_results[[cc]]$eig[2, 2], 1), "%)")) +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(sup_bary_plots[["PT"]] + sup_bary_plots[["ES"]]) /
(sup_bary_plots[["GR"]] + sup_bary_plots[["IT"]]) +
  plot_annotation(title = "MFA Compromise: Oesch-8 Class Barycentres (Dim 1 x 2)")
```

```{r}
#| label: mfa-sup-all-variables

# Print all supplementary barycentre coordinates
for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary barycentres (Dim 1-2) ===\n")
  sup_coord <- mfa_results[[cc]]$quali.var.sup$coord
  print(round(sup_coord[, 1:2], 3))
}
```


# Partial Representations (Round-Specific)

```{r}
#| label: mfa-partial-axes
#| fig-width: 12
#| fig-height: 10

# Partial axes: how closely each round's axes align with the compromise
for (cc in countries) {
  cat("\n===", country_labels[cc], ": Partial axes correlations (Dim 1-2) ===\n")
  pa <- mfa_results[[cc]]$partial.axes$coord
  n_active <- length(mfa_inputs[[cc]]$rounds)
  # Show only active groups
  print(round(pa[1:(n_active * 2), 1:2], 3))
}
```


# Pooled MCA (Robustness Comparison)

As a robustness check, we also run a simple **pooled MCA** on all individuals
across all rounds, with `essround` projected as a supplementary variable. This
gives a single space defined by the overall response structure, without the
multi-table normalisation. If the MFA compromise and the pooled MCA produce
similar category configurations, the results are robust to the choice of method.

```{r}
#| label: pooled-mca
#| cache: true

mca_results <- list()
for (cc in countries) {
  cd <- df %>%
    filter(cntry == cc) %>%
    filter(if_all(all_of(active_vars), ~ !is.na(.)))

  # Prepare: active vars as factors, round as supplementary
  mca_data <- cd %>%
    mutate(across(all_of(active_vars), factor),
           essround = factor(essround))

  # Also add supplementary sociodemographic variables
  for (v in sup_vars_socdem) {
    mca_data[[v]] <- factor(mca_data[[v]])
  }
  if ("lca_class" %in% names(mca_data)) {
    mca_data$lca_class <- factor(mca_data$lca_class)
  }

  sup_cols <- c("essround", sup_vars_socdem)
  if ("lca_class" %in% names(mca_data)) sup_cols <- c(sup_cols, "lca_class")

  mca_input <- mca_data %>% select(all_of(active_vars), all_of(sup_cols))

  cat("Pooled MCA for", country_labels[cc], ": n =", nrow(mca_input), "\n")

  mca_results[[cc]] <- MCA(mca_input,
                            quali.sup = which(names(mca_input) %in% sup_cols),
                            ncp = 5,
                            graph = FALSE)
}
```

```{r}
#| label: pooled-mca-scree
#| fig-width: 10
#| fig-height: 8

J <- length(active_vars)
threshold_pol <- 1 / J

mca_eig_plots <- list()
for (cc in countries) {
  eig <- mca_results[[cc]]$eig
  eig_df <- tibble(
    dim = 1:nrow(eig),
    eigenvalue = eig[, 1],
    retained = eig[, 1] > threshold_pol
  )

  mca_eig_plots[[cc]] <- ggplot(eig_df, aes(dim, eigenvalue, fill = retained)) +
    geom_col(width = 0.7, show.legend = FALSE) +
    geom_hline(yintercept = threshold_pol, linetype = "dashed",
               colour = "red", linewidth = 0.5) +
    annotate("text", x = max(eig_df$dim) - 0.5, y = threshold_pol + 0.01,
             label = paste0("1/J = ", round(threshold_pol, 3)),
             colour = "red", size = 2.8, hjust = 1) +
    scale_fill_manual(values = c("TRUE" = plasma_pal(10)[6],
                                  "FALSE" = "grey75")) +
    scale_x_continuous(breaks = seq(1, nrow(eig_df), by = 2)) +
    labs(title = country_labels[cc], x = "Dimension", y = "Eigenvalue") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(mca_eig_plots[["PT"]] + mca_eig_plots[["ES"]]) /
(mca_eig_plots[["GR"]] + mca_eig_plots[["IT"]]) +
  plot_annotation(
    title = "Political Space: Raw Eigenvalues with Benzécri Threshold",
    subtitle = "Coloured = retained (above 1/J) | Grey = discarded"
  )
```

### Modified Eigenvalues (Benzécri Correction)

In standard MCA, eigenvalues are deflated by the disjunctive (indicator) coding:
total inertia = Q/J − 1, where Q is the total number of categories and J the
number of active variables. The Benzécri correction retains only eigenvalues
above the threshold 1/J and re-expresses them as **modified rates** that better
reflect the true dimensionality of the data. These modified rates are **not**
explained variance (interpretation constraint 5 in CLAUDE.md), but they provide
a more meaningful basis for deciding how many dimensions to retain than the
raw MCA percentages.

With J = `r length(active_vars)` active variables, the threshold is
1/J = `r round(1/length(active_vars), 2)`.

```{r}
#| label: pooled-mca-benzecri-tables

J <- length(active_vars)

mca_benzecri <- list()
for (cc in countries) {
  mca_benzecri[[cc]] <- benzecri_correction(mca_results[[cc]]$eig, J)
  cat("\n===", country_labels[cc], "===\n")
  cat("Eigenvalues above 1/J:", nrow(mca_benzecri[[cc]]), "of",
      nrow(mca_results[[cc]]$eig), "\n")
  print(round(mca_benzecri[[cc]], 4))
}
```

```{r}
#| label: pooled-mca-benzecri-scree
#| fig-width: 10
#| fig-height: 8

mca_mod_plots <- list()
for (cc in countries) {
  bz <- mca_benzecri[[cc]]

  mca_mod_plots[[cc]] <- ggplot(bz, aes(dimension, modified_pct)) +
    geom_col(fill = plasma_pal(10)[6], width = 0.7) +
    geom_line(aes(y = cumulative_pct), colour = "grey40", linewidth = 0.6) +
    geom_point(aes(y = cumulative_pct), colour = "grey40", size = 1.5) +
    scale_x_continuous(breaks = bz$dimension) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(title = country_labels[cc],
         x = "Dimension", y = "Modified rate (%)") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(mca_mod_plots[["PT"]] + mca_mod_plots[["ES"]]) /
(mca_mod_plots[["GR"]] + mca_mod_plots[["IT"]]) +
  plot_annotation(
    title = "Pooled MCA Scree Plots — Benzécri Modified Rates",
    subtitle = "Bars = modified rate per dimension | Line = cumulative %"
  )
```

```{r}
#| label: pooled-mca-benzecri-summary

# Summary comparison: raw vs modified rates for first 2 dimensions
cat("=== Raw vs Modified Rates (Dim 1 & 2) ===\n\n")
for (cc in countries) {
  bz <- mca_benzecri[[cc]]
  raw <- mca_results[[cc]]$eig
  cat(country_labels[cc], ":\n")
  cat("  Dim 1: raw =", round(raw[1, 2], 1), "% → modified =",
      round(bz$modified_pct[1], 1), "%\n")
  cat("  Dim 2: raw =", round(raw[2, 2], 1), "% → modified =",
      round(bz$modified_pct[2], 1), "%\n")
  cat("  Cumulative (2 dims): raw =", round(raw[2, 3], 1),
      "% → modified =", round(bz$cumulative_pct[2], 1), "%\n\n")
}
```

## Dimension Interpretation

### Discrimination Measures (eta²)

eta² indicates how well each active variable discriminates on each dimension.
Higher values mean the variable contributes more to that dimension.

```{r}
#| label: pooled-mca-eta2

for (cc in countries) {
  cat("\n===", country_labels[cc], ": eta² (active variables) ===\n")
  eta2 <- mca_results[[cc]]$var$eta2
  print(round(eta2[, 1:2], 4))
  cat("\n")
}
```

### Top Contributing Categories (Dim 1 & 2)

For each dimension: the categories contributing most to the axis, their cos²
(quality of representation), and v.test (statistical significance of position).
Contributions above the average threshold (100/Q = `r round(100 / sum(sapply(active_vars, function(v) nlevels(factor(df[[v]])))), 1)`%) are highlighted.

```{r}
#| label: pooled-mca-dimdesc

for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  contrib <- as.data.frame(mca_results[[cc]]$var$contrib[, 1:2])
  cos2   <- as.data.frame(mca_results[[cc]]$var$cos2[, 1:2])
  vtest  <- as.data.frame(mca_results[[cc]]$var$v.test[, 1:2])
  coord  <- as.data.frame(mca_results[[cc]]$var$coord[, 1:2])

  diag_df <- tibble(
    category = rownames(contrib),
    coord_1 = coord[, 1], coord_2 = coord[, 2],
    contrib_1 = contrib[, 1], contrib_2 = contrib[, 2],
    cos2_1 = cos2[, 1], cos2_2 = cos2[, 2],
    vtest_1 = vtest[, 1], vtest_2 = vtest[, 2]
  )

  Q <- nrow(diag_df)
  threshold <- 100 / Q

  cat("\nDim 1 — top contributors (threshold =", round(threshold, 1), "%):\n")
  top1 <- diag_df %>%
    filter(contrib_1 > threshold) %>%
    arrange(desc(contrib_1)) %>%
    select(category, coord = coord_1, contrib = contrib_1,
           cos2 = cos2_1, v.test = vtest_1)
  print(as.data.frame(top1), row.names = FALSE)

  cat("\nDim 2 — top contributors:\n")
  top2 <- diag_df %>%
    filter(contrib_2 > threshold) %>%
    arrange(desc(contrib_2)) %>%
    select(category, coord = coord_2, contrib = contrib_2,
           cos2 = cos2_2, v.test = vtest_2)
  print(as.data.frame(top2), row.names = FALSE)
}
```

### Category Maps

```{r}
#| label: pooled-mca-category-maps
#| fig-width: 12
#| fig-height: 10

mca_cat_plots <- list()
for (cc in countries) {
  coord <- as.data.frame(mca_results[[cc]]$var$coord[, 1:2])
  coord$category <- rownames(coord)
  coord$variable <- sub("_.*$", "", coord$category)
  coord$label <- sub("^[^_]+_", "", coord$category)

  # Use Benzécri-corrected rates in axis labels
  bz <- mca_benzecri[[cc]]

  mca_cat_plots[[cc]] <- ggplot(coord, aes(`Dim 1`, `Dim 2`,
                                            colour = variable, label = label)) +
    geom_point(size = 2.5, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    ggrepel::geom_text_repel(size = 3, max.overlaps = 20, show.legend = FALSE) +
    scale_colour_viridis_d(option = "plasma", end = 0.85) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Variable") +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom")
}

(mca_cat_plots[["PT"]] + mca_cat_plots[["ES"]]) /
(mca_cat_plots[["GR"]] + mca_cat_plots[["IT"]]) +
  plot_annotation(title = "Pooled MCA: Category Configurations (Dim 1 x 2)")
```

```{r}
#| label: pooled-mca-supplementary

# Supplementary variable coordinates (including round)
for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary barycentres (Dim 1-2) ===\n")
  print(round(mca_results[[cc]]$quali.sup$coord[, 1:2], 3))
}
```

### Supplementary v.test

v.test assesses whether each supplementary category deviates significantly from
the origin (|v.test| > 1.96 at α = 0.05). Positive values indicate a position
on the positive side of the dimension; negative on the negative side.

```{r}
#| label: pooled-mca-sup-vtest

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary v.test (Dim 1-2) ===\n")
  vt <- as.data.frame(round(mca_results[[cc]]$quali.sup$v.test[, 1:2], 2))
  vt$sig_d1 <- ifelse(abs(vt[, 1]) > 1.96, "*", "")
  vt$sig_d2 <- ifelse(abs(vt[, 2]) > 1.96, "*", "")
  print(vt)
  cat("\n")
}
```

### Supplementary eta² (discrimination)

```{r}
#| label: pooled-mca-sup-eta2

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary eta² (Dim 1-2) ===\n")
  print(round(mca_results[[cc]]$quali.sup$eta2[, 1:2], 4))
  cat("\n")
}
```


# Social Space Construction

The **social space** (espace social) is constructed from structural indicators
of social position: class (Oesch-8), household income, respondent's education,
parental education (mother and father), and urbanisation. This is a separate
analytical object from the political space above: here, social positions define
the axes, and political behaviours — participation repertoires, abstention,
party vote — are projected as supplementary.

**Active variables** (J = 6, Q = 32 categories):

- `oesch8` (8): Class position (Oesch 8-class scheme)
- `income_quint_h` / `income_quint` (5): Household income quintile
- `eisced_5cat_h` (5): Respondent's education (5-cat ISCED, harmonised: eisced + edulvla)
- `mother_edu_5cat` (5): Mother's education
- `father_edu_5cat` (5): Father's education
- `domicil_r` (4): Urbanisation

**Supplementary variables**: ESS round, LCA participation repertoire, vote/abstention,
party families (pending harmonisation).

**Coverage note**: Complete cases on all 6 active variables = 38.2% (25,706 / 67,358)
with the `income_quint_h` version, or 34.3% with `income_quint`. The main bottleneck
is the intersection of class coding (employment-dependent), income (item non-response),
and education (structural missingness in early rounds). Country-specific samples remain
adequate: ES ≈ 11k, PT ≈ 6k, IT ≈ 5.5k, GR ≈ 2.8k.

## Data Preparation

```{r}
#| label: social-space-setup

# Social space variable sets
social_active_h <- c("oesch8", "income_quint_h", "eisced_5cat_h",
                      "mother_edu_5cat", "father_edu_5cat", "domicil_r")
social_active_c <- c("oesch8", "income_quint", "eisced_5cat_h",
                      "mother_edu_5cat", "father_edu_5cat", "domicil_r")

# Oesch-8 short labels for plots
oesch8_labels <- c(
  "1" = "Self-emp prof",
  "2" = "Small business",
  "3" = "Tech (semi-)prof",
  "4" = "Production",
  "5" = "Managers",
  "6" = "Clerks",
  "7" = "Socio-cult prof",
  "8" = "Service workers"
)

# Income quintile labels
income_labels <- c("1" = "Q1 (lowest)", "2" = "Q2", "3" = "Q3",
                    "4" = "Q4", "5" = "Q5 (highest)")

# Education labels (5-cat ISCED)
edu_labels <- c("1" = "ISCED 0-1", "2" = "ISCED 2",
                "3" = "ISCED 3", "4" = "ISCED 4-5", "5" = "ISCED 6+")

# Domicil labels
domicil_labels <- c("1" = "Urban", "2" = "Suburban",
                     "3" = "Town", "4" = "Rural")

# Vote labels
vote_labels <- c("0" = "Did not vote", "1" = "Voted")
```

## Run Social Space MCA (Primary: income_quint_h)

```{r}
#| label: social-mca-run
#| cache: true

soc_results <- list()
soc_benzecri <- list()
J_soc <- length(social_active_h)

for (cc in countries) {
  cd <- df %>%
    filter(cntry == cc) %>%
    filter(if_all(all_of(social_active_h), ~ !is.na(.)))

  # Prepare: active vars as labelled factors, supplementary vars
  soc_data <- cd %>%
    mutate(
      oesch8          = factor(oesch8, levels = 1:8, labels = oesch8_labels),
      income_quint_h  = factor(income_quint_h, levels = 1:5, labels = income_labels),
      eisced_5cat_h   = factor(eisced_5cat_h, levels = 1:5, labels = edu_labels),
      mother_edu_5cat = factor(mother_edu_5cat, levels = 1:5, labels = edu_labels),
      father_edu_5cat = factor(father_edu_5cat, levels = 1:5, labels = edu_labels),
      domicil_r       = factor(domicil_r, levels = 1:4, labels = domicil_labels),
      essround        = factor(essround),
      vote_d          = factor(vote_d, levels = 0:1, labels = vote_labels)
    )

  # Add LCA class if available
  if ("lca_class" %in% names(soc_data) && any(!is.na(soc_data$lca_class))) {
    soc_data$lca_class <- factor(soc_data$lca_class)
  }

  # Build MCA input
  sup_cols_soc <- c("essround", "vote_d")
  if ("lca_class" %in% names(soc_data) && any(!is.na(soc_data$lca_class))) {
    sup_cols_soc <- c(sup_cols_soc, "lca_class")
  }

  soc_input <- soc_data %>%
    select(oesch8, income_quint_h, eisced_5cat_h,
           mother_edu_5cat, father_edu_5cat, domicil_r,
           all_of(sup_cols_soc))

  cat("Social MCA for", country_labels[cc], ": n =", nrow(soc_input), "\n")

  soc_results[[cc]] <- MCA(soc_input,
                            quali.sup = which(names(soc_input) %in% sup_cols_soc),
                            ncp = 5,
                            graph = FALSE)

  # Benzécri correction
  soc_benzecri[[cc]] <- benzecri_correction(soc_results[[cc]]$eig, J_soc)
}
```

## Dimensionality

```{r}
#| label: social-mca-benzecri
#| fig-width: 10
#| fig-height: 8

threshold_soc <- 1 / J_soc

soc_raw_plots <- list()
for (cc in countries) {
  eig <- soc_results[[cc]]$eig
  eig_df <- tibble(
    dim = 1:nrow(eig),
    eigenvalue = eig[, 1],
    retained = eig[, 1] > threshold_soc
  )

  soc_raw_plots[[cc]] <- ggplot(eig_df, aes(dim, eigenvalue, fill = retained)) +
    geom_col(width = 0.7, show.legend = FALSE) +
    geom_hline(yintercept = threshold_soc, linetype = "dashed",
               colour = "red", linewidth = 0.5) +
    annotate("text", x = max(eig_df$dim) - 0.5, y = threshold_soc + 0.01,
             label = paste0("1/J = ", round(threshold_soc, 3)),
             colour = "red", size = 2.8, hjust = 1) +
    scale_fill_manual(values = c("TRUE" = plasma_pal(10)[3],
                                  "FALSE" = "grey75")) +
    scale_x_continuous(breaks = seq(1, nrow(eig_df), by = 2)) +
    labs(title = country_labels[cc], x = "Dimension", y = "Eigenvalue") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(soc_raw_plots[["PT"]] + soc_raw_plots[["ES"]]) /
(soc_raw_plots[["GR"]] + soc_raw_plots[["IT"]]) +
  plot_annotation(
    title = "Social Space: Raw Eigenvalues with Benzécri Threshold",
    subtitle = "Coloured = retained (above 1/J) | Grey = discarded"
  )
```

```{r}
#| label: social-mca-benzecri-tables

cat("Benzécri correction (J =", J_soc, ", threshold = 1/J =",
    round(1/J_soc, 4), ")\n")

for (cc in countries) {
  bz <- soc_benzecri[[cc]]
  cat("\n===", country_labels[cc], "===\n")
  cat("Eigenvalues above threshold:", nrow(bz), "of",
      nrow(soc_results[[cc]]$eig), "\n")
  print(round(bz, 4))
}
```

```{r}
#| label: social-mca-benzecri-scree
#| fig-width: 10
#| fig-height: 8

soc_mod_plots <- list()
for (cc in countries) {
  bz <- soc_benzecri[[cc]]

  soc_mod_plots[[cc]] <- ggplot(bz, aes(dimension, modified_pct)) +
    geom_col(fill = plasma_pal(10)[3], width = 0.7) +
    geom_line(aes(y = cumulative_pct), colour = "grey40", linewidth = 0.6) +
    geom_point(aes(y = cumulative_pct), colour = "grey40", size = 1.5) +
    scale_x_continuous(breaks = bz$dimension) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(title = country_labels[cc],
         x = "Dimension", y = "Modified rate (%)") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(soc_mod_plots[["PT"]] + soc_mod_plots[["ES"]]) /
(soc_mod_plots[["GR"]] + soc_mod_plots[["IT"]]) +
  plot_annotation(
    title = "Social Space MCA — Benzécri Modified Rates",
    subtitle = "Bars = modified rate per dimension | Line = cumulative %"
  )
```

```{r}
#| label: social-mca-benzecri-summary

cat("=== Social Space: Raw vs Modified Rates (Dim 1 & 2) ===\n\n")
for (cc in countries) {
  bz <- soc_benzecri[[cc]]
  raw <- soc_results[[cc]]$eig
  cat(country_labels[cc], ":\n")
  cat("  Dim 1: raw =", round(raw[1, 2], 1), "% → modified =",
      round(bz$modified_pct[1], 1), "%\n")
  cat("  Dim 2: raw =", round(raw[2, 2], 1), "% → modified =",
      round(bz$modified_pct[2], 1), "%\n")
  if (nrow(bz) >= 3) {
    cat("  Dim 3: raw =", round(raw[3, 2], 1), "% → modified =",
        round(bz$modified_pct[3], 1), "%\n")
  }
  cat("  Cumulative (2 dims): raw =", round(raw[2, 3], 1),
      "% → modified =", round(bz$cumulative_pct[min(2, nrow(bz))], 1), "%\n\n")
}
```

## Dimension Interpretation

### Discrimination Measures (eta²)

```{r}
#| label: social-mca-eta2

for (cc in countries) {
  cat("\n===", country_labels[cc], ": eta² (active variables) ===\n")
  eta2 <- soc_results[[cc]]$var$eta2
  print(round(eta2[, 1:2], 4))
  cat("\n")
}
```

### Top Contributing Categories (Dim 1 & 2)

```{r}
#| label: social-mca-dimdesc

for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  contrib <- as.data.frame(soc_results[[cc]]$var$contrib[, 1:2])
  cos2   <- as.data.frame(soc_results[[cc]]$var$cos2[, 1:2])
  vtest  <- as.data.frame(soc_results[[cc]]$var$v.test[, 1:2])
  coord  <- as.data.frame(soc_results[[cc]]$var$coord[, 1:2])

  diag_df <- tibble(
    category = rownames(contrib),
    coord_1 = coord[, 1], coord_2 = coord[, 2],
    contrib_1 = contrib[, 1], contrib_2 = contrib[, 2],
    cos2_1 = cos2[, 1], cos2_2 = cos2[, 2],
    vtest_1 = vtest[, 1], vtest_2 = vtest[, 2]
  )

  Q <- nrow(diag_df)
  threshold <- 100 / Q

  cat("\nDim 1 — top contributors (threshold =", round(threshold, 1), "%):\n")
  top1 <- diag_df %>%
    filter(contrib_1 > threshold) %>%
    arrange(desc(contrib_1)) %>%
    select(category, coord = coord_1, contrib = contrib_1,
           cos2 = cos2_1, v.test = vtest_1)
  print(as.data.frame(top1), row.names = FALSE)

  cat("\nDim 2 — top contributors:\n")
  top2 <- diag_df %>%
    filter(contrib_2 > threshold) %>%
    arrange(desc(contrib_2)) %>%
    select(category, coord = coord_2, contrib = contrib_2,
           cos2 = cos2_2, v.test = vtest_2)
  print(as.data.frame(top2), row.names = FALSE)
}
```

## Category Configuration Maps

```{r}
#| label: social-mca-all-categories
#| fig-width: 14
#| fig-height: 12

# Full category maps coloured by variable
soc_cat_plots <- list()
for (cc in countries) {
  coord <- as.data.frame(soc_results[[cc]]$var$coord[, 1:2])
  coord$category <- rownames(coord)

  # FactoMineR naming: unique labels keep their name (e.g., "Self-emp prof"),
  # but shared labels get variable prefix (e.g., "eisced_5cat_ISCED 0-1")
  # Match categories to variables using known factor levels
  coord$variable <- NA_character_
  coord$variable[coord$category %in% oesch8_labels]  <- "oesch8"
  coord$variable[coord$category %in% income_labels]   <- "income"
  coord$variable[coord$category %in% domicil_labels]  <- "domicil"
  coord$variable[grepl("^eisced_5cat_h_", coord$category)]    <- "education"
  coord$variable[grepl("^mother_edu_5cat_", coord$category)] <- "mother_edu"
  coord$variable[grepl("^father_edu_5cat_", coord$category)] <- "father_edu"

  # Clean labels: prefix education variables for readability
  coord$label <- coord$category
  coord$label <- gsub("^eisced_5cat_h_", "Resp: ", coord$label)
  coord$label <- gsub("^mother_edu_5cat_", "M: ", coord$label)
  coord$label <- gsub("^father_edu_5cat_", "F: ", coord$label)

  bz <- soc_benzecri[[cc]]

  soc_cat_plots[[cc]] <- ggplot(coord, aes(`Dim 1`, `Dim 2`,
                                            colour = variable, label = label)) +
    geom_point(size = 2, alpha = 0.7) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    ggrepel::geom_text_repel(size = 2.3, max.overlaps = 30, show.legend = FALSE) +
    scale_colour_viridis_d(option = "plasma", end = 0.85) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Variable") +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom")
}

(soc_cat_plots[["PT"]] + soc_cat_plots[["ES"]]) /
(soc_cat_plots[["GR"]] + soc_cat_plots[["IT"]]) +
  plot_annotation(title = "Social Space: All Active Category Configurations (Dim 1 x 2)")
```

## Oesch-8 Class Positions

Focused map showing only the Oesch-8 class category positions within the social
space, with participation repertoires and vote/abstention projected as
supplementary barycentres.

```{r}
#| label: social-mca-oesch-focused
#| fig-width: 12
#| fig-height: 10

soc_oesch_plots <- list()
for (cc in countries) {
  # Active Oesch-8 coordinates (matched by factor level labels, not prefix)
  all_coord <- as.data.frame(soc_results[[cc]]$var$coord[, 1:2])
  all_coord$category <- rownames(all_coord)
  oesch_coord <- all_coord %>%
    filter(category %in% oesch8_labels) %>%
    mutate(label = category,
           type = "Oesch-8 class")

  # Supplementary barycentres: LCA class + vote
  sup_coord <- as.data.frame(soc_results[[cc]]$quali.sup$coord[, 1:2])
  sup_coord$category <- rownames(sup_coord)
  sup_coord$label <- gsub("^vote_d_", "", sup_coord$category)
  sup_coord$label <- gsub("^lca_class_", "LCA ", sup_coord$label)
  sup_coord$label <- gsub("^essround_", "R", sup_coord$label)

  # Separate by type
  sup_vote <- sup_coord %>%
    filter(grepl("^vote_d_", category)) %>%
    mutate(type = "Vote")
  sup_lca  <- sup_coord %>%
    filter(grepl("^lca_class_", category)) %>%
    mutate(type = "LCA repertoire")
  sup_round <- sup_coord %>%
    filter(grepl("^essround_", category)) %>%
    mutate(type = "Round")

  bz <- soc_benzecri[[cc]]

  p <- ggplot() +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    # Oesch-8 categories (large, bold)
    geom_point(data = oesch_coord, aes(`Dim 1`, `Dim 2`),
               colour = plasma_pal(10)[2], size = 4, shape = 16) +
    ggrepel::geom_text_repel(data = oesch_coord,
                              aes(`Dim 1`, `Dim 2`, label = label),
                              size = 3.2, fontface = "bold",
                              colour = plasma_pal(10)[2],
                              max.overlaps = 20) +
    # LCA repertoire classes (triangles)
    geom_point(data = sup_lca, aes(`Dim 1`, `Dim 2`),
               colour = plasma_pal(10)[6], size = 3.5, shape = 17) +
    ggrepel::geom_text_repel(data = sup_lca,
                              aes(`Dim 1`, `Dim 2`, label = label),
                              size = 2.8, colour = plasma_pal(10)[6],
                              max.overlaps = 10) +
    # Vote/abstention (squares)
    geom_point(data = sup_vote, aes(`Dim 1`, `Dim 2`),
               colour = plasma_pal(10)[8], size = 3.5, shape = 15) +
    ggrepel::geom_text_repel(data = sup_vote,
                              aes(`Dim 1`, `Dim 2`, label = label),
                              size = 2.8, colour = plasma_pal(10)[8],
                              max.overlaps = 10) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)")) +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold", size = 11))

  soc_oesch_plots[[cc]] <- p
}

(soc_oesch_plots[["PT"]] + soc_oesch_plots[["ES"]]) /
(soc_oesch_plots[["GR"]] + soc_oesch_plots[["IT"]]) +
  plot_annotation(
    title = "Social Space: Oesch-8 Classes + Participation & Vote",
    subtitle = "Circles = Oesch-8 (active) | Triangles = LCA repertoires (sup.) | Squares = Vote (sup.)"
  )
```

## Supplementary Barycentres

```{r}
#| label: social-mca-supplementary

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary barycentres (Dim 1-2) ===\n")
  print(round(soc_results[[cc]]$quali.sup$coord[, 1:2], 3))
}
```

### Supplementary v.test

```{r}
#| label: social-mca-sup-vtest

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary v.test (Dim 1-2) ===\n")
  vt <- as.data.frame(round(soc_results[[cc]]$quali.sup$v.test[, 1:2], 2))
  vt$sig_d1 <- ifelse(abs(vt[, 1]) > 1.96, "*", "")
  vt$sig_d2 <- ifelse(abs(vt[, 2]) > 1.96, "*", "")
  print(vt)
  cat("\n")
}
```

### Supplementary eta²

```{r}
#| label: social-mca-sup-eta2

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary eta² (Dim 1-2) ===\n")
  print(round(soc_results[[cc]]$quali.sup$eta2[, 1:2], 4))
  cat("\n")
}
```

## Variable Contributions

```{r}
#| label: social-mca-contributions

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Top 15 category contributions ===\n")

  cat_contrib <- soc_results[[cc]]$var$contrib
  cat_coord   <- soc_results[[cc]]$var$coord

  cat("\n-- Dim 1 (top 15 contributors) --\n")
  top1 <- head(cat_contrib[order(-cat_contrib[, 1]), , drop = FALSE], 15)
  print(round(cbind(contrib = top1[, 1, drop = FALSE],
                    coord = cat_coord[rownames(top1), 1]), 3))

  cat("\n-- Dim 2 (top 15 contributors) --\n")
  top2 <- head(cat_contrib[order(-cat_contrib[, 2]), , drop = FALSE], 15)
  print(round(cbind(contrib = top2[, 2, drop = FALSE],
                    coord = cat_coord[rownames(top2), 2]), 3))
}
```

## Robustness: income_quint (R4–11 only)

```{r}
#| label: social-mca-robustness
#| cache: true

soc_results_rob <- list()
soc_benzecri_rob <- list()

for (cc in countries) {
  cd <- df %>%
    filter(cntry == cc) %>%
    filter(if_all(all_of(social_active_c), ~ !is.na(.)))

  soc_data <- cd %>%
    mutate(
      oesch8          = factor(oesch8, levels = 1:8, labels = oesch8_labels),
      income_quint    = factor(income_quint, levels = 1:5, labels = income_labels),
      eisced_5cat_h   = factor(eisced_5cat_h, levels = 1:5, labels = edu_labels),
      mother_edu_5cat = factor(mother_edu_5cat, levels = 1:5, labels = edu_labels),
      father_edu_5cat = factor(father_edu_5cat, levels = 1:5, labels = edu_labels),
      domicil_r       = factor(domicil_r, levels = 1:4, labels = domicil_labels),
      essround        = factor(essround),
      vote_d          = factor(vote_d, levels = 0:1, labels = vote_labels)
    )

  if ("lca_class" %in% names(soc_data) && any(!is.na(soc_data$lca_class))) {
    soc_data$lca_class <- factor(soc_data$lca_class)
  }

  sup_cols_rob <- c("essround", "vote_d")
  if ("lca_class" %in% names(soc_data) && any(!is.na(soc_data$lca_class))) {
    sup_cols_rob <- c(sup_cols_rob, "lca_class")
  }

  soc_input <- soc_data %>%
    select(oesch8, income_quint, eisced_5cat_h,
           mother_edu_5cat, father_edu_5cat, domicil_r,
           all_of(sup_cols_rob))

  cat("Robustness MCA for", country_labels[cc], ": n =", nrow(soc_input), "\n")

  soc_results_rob[[cc]] <- MCA(soc_input,
                                quali.sup = which(names(soc_input) %in% sup_cols_rob),
                                ncp = 5,
                                graph = FALSE)

  soc_benzecri_rob[[cc]] <- benzecri_correction(soc_results_rob[[cc]]$eig, J_soc)
}
```

```{r}
#| label: social-mca-robustness-summary

cat("=== Robustness (income_quint): Raw vs Modified Rates ===\n\n")
for (cc in countries) {
  bz <- soc_benzecri_rob[[cc]]
  bz_h <- soc_benzecri[[cc]]
  cat(country_labels[cc], ":\n")
  cat("  Primary   (income_quint_h) — Dim 1:", round(bz_h$modified_pct[1], 1),
      "%, Dim 2:", round(bz_h$modified_pct[2], 1), "%\n")
  cat("  Robustness (income_quint)  — Dim 1:", round(bz$modified_pct[1], 1),
      "%, Dim 2:", round(bz$modified_pct[2], 1), "%\n\n")
}
```


# Class-Comparison Space

MCA on **resource indicators only** (income, education, domicil) — without any
class scheme as active. Oesch-8, ORDC, and EGP-11 are projected as
supplementary barycentres. Categories within each scheme are connected by lines,
revealing how different class typologies map onto the same resource space.

Active variables (J = 5, Q = 24):

- `income_quint_h` (5): Household income quintile
- `eisced_5cat_h` (5): Respondent's education (harmonised)
- `mother_edu_5cat` (5): Mother's education
- `father_edu_5cat` (5): Father's education
- `domicil_r` (4): Urbanisation

Supplementary: `oesch8`, `ordc`, `egp11`, `essround`.

```{r}
#| label: class-comp-setup

# Active resource variables (no class scheme)
resource_active <- c("income_quint_h", "eisced_5cat_h",
                     "mother_edu_5cat", "father_edu_5cat", "domicil_r")

# ORDC short labels (exclude 996 = Unclassifiable)
ordc_labels <- c(
  "1"   = "Cult Upper",
  "2"   = "Bal Upper",
  "3"   = "Econ Upper",
  "4"   = "Cult Up-Mid",
  "5"   = "Bal Up-Mid",
  "6.1" = "Econ Up-Mid(a)",
  "6.2" = "Econ Up-Mid(b)",
  "7"   = "Cult Lo-Mid",
  "8"   = "Bal Lo-Mid",
  "10"  = "Skill WC",
  "11"  = "Unskill WC",
  "12"  = "Primary"
)

# EGP-11 short labels
egp_labels <- c(
  "1"  = "I Hi Prof",
  "2"  = "II Lo Prof",
  "3"  = "IIIa Rout NM+",
  "4"  = "IIIb Rout NM-",
  "5"  = "IVa Sm Prop+",
  "7"  = "IVc Farmer",
  "8"  = "V Lo Tech",
  "9"  = "VI Skill Man",
  "10" = "VIIa Unskill",
  "11" = "VIIb Farm Lab"
)
```

```{r}
#| label: class-comp-run
#| cache: true

comp_results <- list()
comp_benzecri <- list()
J_comp <- length(resource_active)

for (cc in countries) {
  cd <- df %>%
    filter(cntry == cc) %>%
    filter(if_all(all_of(resource_active), ~ !is.na(.)))

  comp_data <- cd %>%
    mutate(
      income_quint_h  = factor(income_quint_h, levels = 1:5, labels = income_labels),
      eisced_5cat_h   = factor(eisced_5cat_h, levels = 1:5, labels = edu_labels),
      mother_edu_5cat = factor(mother_edu_5cat, levels = 1:5, labels = edu_labels),
      father_edu_5cat = factor(father_edu_5cat, levels = 1:5, labels = edu_labels),
      domicil_r       = factor(domicil_r, levels = 1:4, labels = domicil_labels),
      # Supplementary class schemes
      oesch8 = factor(oesch8, levels = 1:8, labels = oesch8_labels),
      ordc   = factor(ordc, levels = names(ordc_labels), labels = ordc_labels),
      egp11  = factor(egp11, levels = names(egp_labels), labels = egp_labels),
      essround = factor(essround)
    )

  sup_cols_comp <- c("oesch8", "ordc", "egp11", "essround")

  comp_input <- comp_data %>%
    select(all_of(resource_active), all_of(sup_cols_comp))

  # Drop rows where ALL supplementary class vars are NA (keep if at least 1 exists)
  # FactoMineR handles NA in supplementary gracefully

  cat("Class-comparison MCA for", country_labels[cc], ": n =", nrow(comp_input), "\n")

  comp_results[[cc]] <- MCA(comp_input,
                             quali.sup = which(names(comp_input) %in% sup_cols_comp),
                             ncp = 5,
                             graph = FALSE)

  comp_benzecri[[cc]] <- benzecri_correction(comp_results[[cc]]$eig, J_comp)
}
```

## Dimensionality

```{r}
#| label: class-comp-benzecri
#| fig-width: 10
#| fig-height: 8

cat("Benzécri correction (J =", J_comp, ", threshold = 1/J =",
    round(1/J_comp, 4), ")\n")

for (cc in countries) {
  bz <- comp_benzecri[[cc]]
  cat("\n===", country_labels[cc], "===\n")
  cat("Eigenvalues above threshold:", nrow(bz), "of",
      nrow(comp_results[[cc]]$eig), "\n")
  print(round(bz, 4))
}
```

```{r}
#| label: class-comp-scree
#| fig-width: 10
#| fig-height: 8

threshold_comp <- 1 / J_comp

comp_eig_plots <- list()
for (cc in countries) {
  eig <- comp_results[[cc]]$eig
  eig_df <- tibble(
    dim = 1:nrow(eig),
    eigenvalue = eig[, 1],
    retained = eig[, 1] > threshold_comp
  )

  comp_eig_plots[[cc]] <- ggplot(eig_df, aes(dim, eigenvalue, fill = retained)) +
    geom_col(width = 0.7, show.legend = FALSE) +
    geom_hline(yintercept = threshold_comp, linetype = "dashed",
               colour = "red", linewidth = 0.5) +
    annotate("text", x = max(eig_df$dim) - 0.5, y = threshold_comp + 0.01,
             label = paste0("1/J = ", round(threshold_comp, 3)),
             colour = "red", size = 2.8, hjust = 1) +
    scale_fill_manual(values = c("TRUE" = plasma_pal(10)[8],
                                  "FALSE" = "grey75")) +
    scale_x_continuous(breaks = seq(1, nrow(eig_df), by = 2)) +
    labs(title = country_labels[cc], x = "Dimension", y = "Eigenvalue") +
    theme(plot.title = element_text(face = "bold", size = 11))
}

(comp_eig_plots[["PT"]] + comp_eig_plots[["ES"]]) /
(comp_eig_plots[["GR"]] + comp_eig_plots[["IT"]]) +
  plot_annotation(
    title = "Class-Comparison Space: Raw Eigenvalues with Benzécri Threshold",
    subtitle = "Coloured = retained (above 1/J) | Grey = discarded"
  )
```

### Discrimination Measures (eta²)

```{r}
#| label: class-comp-eta2

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Active eta² ===\n")
  print(round(comp_results[[cc]]$var$eta2[, 1:2], 4))
  cat("\nSupplementary eta² (class schemes):\n")
  print(round(comp_results[[cc]]$quali.sup$eta2[, 1:2], 4))
  cat("\n")
}
```

### Top Contributing Categories

```{r}
#| label: class-comp-dimdesc

for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  contrib <- as.data.frame(comp_results[[cc]]$var$contrib[, 1:2])
  cos2   <- as.data.frame(comp_results[[cc]]$var$cos2[, 1:2])
  vtest  <- as.data.frame(comp_results[[cc]]$var$v.test[, 1:2])
  coord  <- as.data.frame(comp_results[[cc]]$var$coord[, 1:2])

  diag_df <- tibble(
    category = rownames(contrib),
    coord_1 = coord[, 1], coord_2 = coord[, 2],
    contrib_1 = contrib[, 1], contrib_2 = contrib[, 2],
    cos2_1 = cos2[, 1], cos2_2 = cos2[, 2],
    vtest_1 = vtest[, 1], vtest_2 = vtest[, 2]
  )

  Q <- nrow(diag_df)
  threshold <- 100 / Q

  cat("\nDim 1 — top contributors (threshold =", round(threshold, 1), "%):\n")
  top1 <- diag_df %>%
    filter(contrib_1 > threshold) %>%
    arrange(desc(contrib_1)) %>%
    select(category, coord = coord_1, contrib = contrib_1,
           cos2 = cos2_1, v.test = vtest_1)
  print(as.data.frame(top1), row.names = FALSE)

  cat("\nDim 2 — top contributors:\n")
  top2 <- diag_df %>%
    filter(contrib_2 > threshold) %>%
    arrange(desc(contrib_2)) %>%
    select(category, coord = coord_2, contrib = contrib_2,
           cos2 = cos2_2, v.test = vtest_2)
  print(as.data.frame(top2), row.names = FALSE)
}
```

### Supplementary v.test (Class Schemes)

```{r}
#| label: class-comp-sup-vtest

for (cc in countries) {
  cat("\n===", country_labels[cc], ": Supplementary v.test (Dim 1-2) ===\n")
  vt <- as.data.frame(round(comp_results[[cc]]$quali.sup$v.test[, 1:2], 2))
  vt$sig_d1 <- ifelse(abs(vt[, 1]) > 1.96, "*", "")
  vt$sig_d2 <- ifelse(abs(vt[, 2]) > 1.96, "*", "")
  print(vt)
  cat("\n")
}
```

## Class Scheme Comparison Map

Each class scheme's supplementary barycentres are plotted in the resource space.
Categories within each scheme are connected by a path (ordered by Dim 1
coordinate), showing how the scheme's hierarchy maps onto the capital volume axis.

```{r}
#| label: class-comp-map
#| fig-width: 14
#| fig-height: 12

comp_plots <- list()
for (cc in countries) {
  bz <- comp_benzecri[[cc]]

  # Get supplementary barycentres
  sup_coord <- as.data.frame(comp_results[[cc]]$quali.sup$coord[, 1:2])
  sup_coord$category <- rownames(sup_coord)

  # Parse scheme from category name prefix
  sup_coord$scheme <- NA_character_
  sup_coord$label <- sup_coord$category

  # Oesch-8 labels are unique (no prefix added by FactoMineR)
  sup_coord$scheme[sup_coord$category %in% oesch8_labels] <- "Oesch-8"

  # ORDC labels are unique
  sup_coord$scheme[sup_coord$category %in% ordc_labels] <- "ORDC"

  # EGP labels are unique
  sup_coord$scheme[sup_coord$category %in% egp_labels] <- "EGP-11"

  # Remove round barycentres (keep only class schemes)
  class_coord <- sup_coord %>% filter(!is.na(scheme))

  # Order within each scheme by Dim 1 for the connecting path
  class_coord <- class_coord %>%
    arrange(scheme, `Dim 1`)

  p <- ggplot(class_coord, aes(`Dim 1`, `Dim 2`, colour = scheme)) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    # Connecting paths (ordered by Dim 1)
    geom_path(aes(group = scheme), linewidth = 0.5, alpha = 0.5) +
    geom_point(size = 3, alpha = 0.8) +
    ggrepel::geom_text_repel(aes(label = label), size = 2.4,
                              max.overlaps = 35, show.legend = FALSE,
                              segment.alpha = 0.3) +
    scale_colour_manual(values = c("Oesch-8" = "#7B2D8E",
                                    "ORDC"    = "#E6550D",
                                    "EGP-11"  = "#31A354")) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Class scheme") +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom")

  comp_plots[[cc]] <- p
}

(comp_plots[["PT"]] + comp_plots[["ES"]]) /
(comp_plots[["GR"]] + comp_plots[["IT"]]) +
  plot_annotation(
    title = "Class-Comparison Space: Oesch-8 / ORDC / EGP-11 in Resource Space",
    subtitle = "Resource-only MCA (income, education, domicil). Class schemes projected as supplementary."
  )
```


# Diachronic Trajectories

Temporal trajectories of class barycentres across ESS rounds. For each class
category (Oesch-8), we compute the mean coordinates (barycentre) of all
individuals in that category for each round, then connect them with arrows
showing the direction of movement.

Two perspectives:

1. **Political space**: how the political orientations of each class shift over time
2. **Social space**: how structural positions shift (less expected movement)

Party family trajectories will be added once the CHES/Party Manifesto
harmonisation is complete.

## Class Trajectories in Political Space

```{r}
#| label: trajectory-political
#| fig-width: 14
#| fig-height: 12

pol_traj_plots <- list()
for (cc in countries) {
  # Individual coordinates from pooled MCA
  ind_coord <- as.data.frame(mca_results[[cc]]$ind$coord[, 1:2])
  names(ind_coord) <- c("Dim1", "Dim2")

  # Get the data used for MCA (same filtering as pooled-mca chunk)
  cd <- df %>%
    filter(cntry == cc) %>%
    filter(if_all(all_of(active_vars), ~ !is.na(.)))

  ind_coord$oesch8 <- factor(cd$oesch8, levels = 1:8, labels = oesch8_labels)
  ind_coord$essround <- cd$essround

  # Filter to non-NA class and compute barycentres
  traj <- ind_coord %>%
    filter(!is.na(oesch8)) %>%
    group_by(oesch8, essround) %>%
    summarise(Dim1 = mean(Dim1), Dim2 = mean(Dim2), n = n(),
              .groups = "drop") %>%
    filter(n >= 30)  # minimum cell size

  bz <- mca_benzecri[[cc]]

  p <- ggplot(traj, aes(Dim1, Dim2, colour = oesch8)) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_path(aes(group = oesch8), arrow = arrow(length = unit(0.08, "inches"),
              type = "closed"), linewidth = 0.5, alpha = 0.6) +
    geom_point(size = 1.5, alpha = 0.7) +
    # Label first and last round for each class
    ggrepel::geom_text_repel(
      data = traj %>% group_by(oesch8) %>%
        filter(essround == min(essround) | essround == max(essround)),
      aes(label = paste0(oesch8, "\nR", essround)),
      size = 2, max.overlaps = 30, show.legend = FALSE, segment.alpha = 0.3) +
    scale_colour_viridis_d(option = "plasma", end = 0.9) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Oesch-8") +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom",
          legend.text = element_text(size = 7))

  pol_traj_plots[[cc]] <- p
}

(pol_traj_plots[["PT"]] + pol_traj_plots[["ES"]]) /
(pol_traj_plots[["GR"]] + pol_traj_plots[["IT"]]) +
  plot_annotation(
    title = "Oesch-8 Class Trajectories in Political Space",
    subtitle = "Arrows show movement from earliest to latest round (min 30 obs per cell)"
  )
```

## Class Trajectories in Social Space

```{r}
#| label: trajectory-social
#| fig-width: 14
#| fig-height: 12

soc_traj_plots <- list()
for (cc in countries) {
  # Individual coordinates from social MCA
  ind_coord <- as.data.frame(soc_results[[cc]]$ind$coord[, 1:2])
  names(ind_coord) <- c("Dim1", "Dim2")

  # Get the data used for social MCA
  cd <- df %>%
    filter(cntry == cc) %>%
    filter(if_all(all_of(social_active_h), ~ !is.na(.)))

  ind_coord$essround <- cd$essround

  # Oesch-8 is already in the social space as active — use class variable directly
  ind_coord$oesch8 <- factor(cd$oesch8, levels = 1:8, labels = oesch8_labels)

  traj <- ind_coord %>%
    filter(!is.na(oesch8)) %>%
    group_by(oesch8, essround) %>%
    summarise(Dim1 = mean(Dim1), Dim2 = mean(Dim2), n = n(),
              .groups = "drop") %>%
    filter(n >= 30)

  bz <- soc_benzecri[[cc]]

  p <- ggplot(traj, aes(Dim1, Dim2, colour = oesch8)) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_path(aes(group = oesch8), arrow = arrow(length = unit(0.08, "inches"),
              type = "closed"), linewidth = 0.5, alpha = 0.6) +
    geom_point(size = 1.5, alpha = 0.7) +
    ggrepel::geom_text_repel(
      data = traj %>% group_by(oesch8) %>%
        filter(essround == min(essround) | essround == max(essround)),
      aes(label = paste0(oesch8, "\nR", essround)),
      size = 2, max.overlaps = 30, show.legend = FALSE, segment.alpha = 0.3) +
    scale_colour_viridis_d(option = "plasma", end = 0.9) +
    labs(title = country_labels[cc],
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Oesch-8") +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom",
          legend.text = element_text(size = 7))

  soc_traj_plots[[cc]] <- p
}

(soc_traj_plots[["PT"]] + soc_traj_plots[["ES"]]) /
(soc_traj_plots[["GR"]] + soc_traj_plots[["IT"]]) +
  plot_annotation(
    title = "Oesch-8 Class Trajectories in Social Space",
    subtitle = "Arrows show movement from earliest to latest round (min 30 obs per cell)"
  )
```


# Cluster Analysis on MCA Coordinates

Following Carvalho (2008) and the Craveiro workflow: hierarchical clustering
(Ward's method) on MCA individual coordinates, followed by K-means
consolidation. The `HCPC()` function from FactoMineR implements this two-step
approach. Clustering is performed on all retained dimensions (ncp = 5) to use
the full information, but visualised on Dim 1 × 2.

## Political Space Clusters

```{r}
#| label: cluster-political-hcpc
#| cache: true

pol_hcpc <- list()
for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  pol_hcpc[[cc]] <- HCPC(mca_results[[cc]], nb.clust = -1,
                          consol = TRUE, graph = FALSE)
  cat("Optimal K:", length(unique(pol_hcpc[[cc]]$data.clust$clust)), "\n")
}
```

### Dendrogram & Cluster Map

```{r}
#| label: cluster-political-map
#| fig-width: 14
#| fig-height: 12

pol_clust_plots <- list()
for (cc in countries) {
  hc <- pol_hcpc[[cc]]
  # Coordinates from MCA, cluster assignment from HCPC
  clust_data <- as.data.frame(mca_results[[cc]]$ind$coord[, 1:2])
  names(clust_data) <- c("Dim1", "Dim2")
  clust_data$cluster <- hc$data.clust$clust

  bz <- mca_benzecri[[cc]]

  p <- ggplot(clust_data, aes(Dim1, Dim2, colour = cluster)) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_point(size = 0.3, alpha = 0.3) +
    stat_ellipse(level = 0.8, linewidth = 0.6) +
    scale_colour_viridis_d(option = "plasma", end = 0.85) +
    labs(title = paste0(country_labels[cc], " (K = ",
                        length(unique(clust_data$cluster)), ")"),
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Cluster") +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom")

  pol_clust_plots[[cc]] <- p
}

(pol_clust_plots[["PT"]] + pol_clust_plots[["ES"]]) /
(pol_clust_plots[["GR"]] + pol_clust_plots[["IT"]]) +
  plot_annotation(
    title = "Political Space: Cluster Analysis (Ward + K-means consolidation)",
    subtitle = "Points = individuals coloured by cluster | Ellipses = 80% concentration"
  )
```

### Cluster Description

```{r}
#| label: cluster-political-desc

for (cc in countries) {
  hc <- pol_hcpc[[cc]]
  K <- length(unique(hc$data.clust$clust))
  cat("\n===", country_labels[cc], "(K =", K, ") ===\n")

  # Cluster sizes
  cat("\nCluster sizes:\n")
  print(table(hc$data.clust$clust))

  # Most characteristic categories per cluster (v.test)
  cat("\nCharacteristic categories (|v.test| > 2):\n")
  desc <- hc$desc.var$category
  for (k in seq_along(desc)) {
    cat("\n  Cluster", k, ":\n")
    d <- as.data.frame(desc[[k]])
    d$category <- rownames(d)
    sig <- d %>%
      filter(abs(v.test) > 2) %>%
      arrange(desc(abs(v.test))) %>%
      head(10)
    if (nrow(sig) > 0) {
      print(sig[, c("category", "v.test", "p.value")], row.names = FALSE)
    } else {
      cat("    (no categories with |v.test| > 2)\n")
    }
  }
}
```

## Social Space Clusters

```{r}
#| label: cluster-social-hcpc
#| cache: true

soc_hcpc <- list()
for (cc in countries) {
  cat("\n===", country_labels[cc], "===\n")
  soc_hcpc[[cc]] <- HCPC(soc_results[[cc]], nb.clust = -1,
                          consol = TRUE, graph = FALSE)
  cat("Optimal K:", length(unique(soc_hcpc[[cc]]$data.clust$clust)), "\n")
}
```

```{r}
#| label: cluster-social-map
#| fig-width: 14
#| fig-height: 12

soc_clust_plots <- list()
for (cc in countries) {
  hc <- soc_hcpc[[cc]]
  clust_data <- as.data.frame(soc_results[[cc]]$ind$coord[, 1:2])
  names(clust_data) <- c("Dim1", "Dim2")
  clust_data$cluster <- hc$data.clust$clust

  bz <- soc_benzecri[[cc]]

  p <- ggplot(clust_data, aes(Dim1, Dim2, colour = cluster)) +
    geom_hline(yintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_vline(xintercept = 0, linetype = "dashed", colour = "grey60") +
    geom_point(size = 0.3, alpha = 0.3) +
    stat_ellipse(level = 0.8, linewidth = 0.6) +
    scale_colour_viridis_d(option = "plasma", end = 0.85) +
    labs(title = paste0(country_labels[cc], " (K = ",
                        length(unique(clust_data$cluster)), ")"),
         x = paste0("Dim 1 (", round(bz$modified_pct[1], 1), "%)"),
         y = paste0("Dim 2 (", round(bz$modified_pct[2], 1), "%)"),
         colour = "Cluster") +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold", size = 11),
          legend.position = "bottom")

  soc_clust_plots[[cc]] <- p
}

(soc_clust_plots[["PT"]] + soc_clust_plots[["ES"]]) /
(soc_clust_plots[["GR"]] + soc_clust_plots[["IT"]]) +
  plot_annotation(
    title = "Social Space: Cluster Analysis (Ward + K-means consolidation)",
    subtitle = "Points = individuals coloured by cluster | Ellipses = 80% concentration"
  )
```

### Cluster Description

```{r}
#| label: cluster-social-desc

for (cc in countries) {
  hc <- soc_hcpc[[cc]]
  K <- length(unique(hc$data.clust$clust))
  cat("\n===", country_labels[cc], "(K =", K, ") ===\n")

  cat("\nCluster sizes:\n")
  print(table(hc$data.clust$clust))

  cat("\nCharacteristic categories (|v.test| > 2):\n")
  desc <- hc$desc.var$category
  for (k in seq_along(desc)) {
    cat("\n  Cluster", k, ":\n")
    d <- as.data.frame(desc[[k]])
    d$category <- rownames(d)
    sig <- d %>%
      filter(abs(v.test) > 2) %>%
      arrange(desc(abs(v.test))) %>%
      head(10)
    if (nrow(sig) > 0) {
      print(sig[, c("category", "v.test", "p.value")], row.names = FALSE)
    } else {
      cat("    (no categories with |v.test| > 2)\n")
    }
  }
}
```


# Save Workspace {.unnumbered}

```{r}
#| label: save-workspace
#| cache: false

# Save all results for downstream consumer documents
save(
  df, mfa_results, mfa_inputs, mca_results, mca_benzecri,
  soc_results, soc_benzecri, soc_results_rob, soc_benzecri_rob,
  comp_results, comp_benzecri,
  pol_hcpc, soc_hcpc,
  lca_models, lca_selected, lca_fits, selected_k,
  active_vars, participation_vars, sup_vars_socdem, sup_all,
  social_active_h, social_active_c, resource_active,
  oesch8_labels, income_labels, edu_labels, domicil_labels, vote_labels,
  ordc_labels, egp_labels,
  countries, country_labels,
  file = "saved/analysis.Rdata"
)

cat("Workspace saved to saved/analysis.Rdata\n")
cat("Objects:", paste(ls(), collapse = ", "), "\n")
```
